#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Fatigue Edge v2.1 — Reglas (PERCLOS/EAR/MAR) + ROI + Alerts + Telemetry + Health
- SIN TensorFlow. MediaPipe Face Detection (opcional) + FaceMesh.
- Estados EXACTOS por tu tabla. PERCLOS ventana 10 s. Tasas por minuto (60 s).
- BLOQUEO de falsos 'somnolencia' por pocos blinks al inicio: se exige cobertura temporal.

MQTT topics:
- fatiga/estado     -> estado principal (payload compacto)
- fatiga/alerta     -> cambios de nivel de alerta (0..3) con histéresis
- telemetry/health  -> métricas de salud (fps, temp, watchdog, no-face)

© PF Luciana
"""
import os, time, math, json, threading, queue, argparse
from collections import deque
from dataclasses import dataclass
from typing import Optional, Tuple
import numpy as np, cv2

# ===== MQTT opcional =====
try:
    from paho.mqtt import client as mqtt
except Exception:
    mqtt = None

# ===== MediaPipe =====
MP_OK = True
try:
    import mediapipe as mp
except Exception:
    MP_OK = False

# ---------------- Config ----------------
# (AQUÍ AJUSTAS) cámara
CAM_SIZE = (640, 480)
TARGET_FPS = 30

# (AQUÍ AJUSTAS) frecuencias de procesamiento
FACEMESH_HZ = 20.0                 # 15–25 Hz recomendado para FaceMesh
DETECT_HZ   = 7.0                  # 5–10 Hz para ROI (Face Detection)

# (AQUÍ AJUSTAS) umbrales de eventos (dados por ti)
EAR_BLINK_TH = 0.09                # parpadeo si EAR < 0.09
MAR_YAWN_TH  = 0.65                # bostezo si MAR > 0.65

# (AQUÍ AJUSTAS) ventanas temporales
PERCLOS_WINDOW_SEC   = 10.0        # 10 s para PERCLOS (más estabilidad)
EVENT_RATE_WINDOW_S  = 60.0        # blinks / yawns por minuto (últimos 60 s)

# (AQUÍ AJUSTAS) confianza mínima por cobertura
MIN_COVERAGE_BLINKS_S = 45.0       # exigir >=45 s para usar blinks en la decisión
MIN_COVERAGE_YAWNS_S  = 30.0       # (opcional) exigir >=30 s para usar yawns en reglas estrictas

# (AQUÍ AJUSTAS) ROI
ROI_MARGIN = 0.20                  # margen extra alrededor del face bbox

# (AQUÍ AJUSTAS) alertas (escalamiento / histéresis)
SOMNO_LVL1_S = 10.0
SOMNO_LVL2_S = 20.0
SOMNO_LVL3_S = 40.0
FATIGA_LVL1_S = 10.0
FATIGA_LVL2_S = 20.0
RECOVERY_DOWN_S = 15.0             # tiempo en NORMAL para bajar de nivel

# ---------------- Verbose flag (logs)
VERBOSE = False

def vprint(*args, **kwargs):
    if VERBOSE:
        print(*args, **kwargs)

# ---------------- Data ----------------
def now() -> float: return time.time()

@dataclass
class Frame:    ts:float; bgr:np.ndarray; fps:float
@dataclass
class FaceROI:  ts:float; xyxy:Tuple[int,int,int,int]; conf:float
@dataclass
class Landmarks: ts:float; pts:np.ndarray  # (468,2) coords en FULL FRAME
@dataclass
class Features:
    ts:float; ear:float; mar:float; perclos:float
    blinks:int; yawns:int
    blink_cov_s: float; yawn_cov_s: float   # cobertura (segundos observados)

# ---------------- Queues & helpers ----------------
stop = threading.Event()
q_frame = queue.Queue(maxsize=4)
q_roi   = queue.Queue(maxsize=2)
q_lm    = queue.Queue(maxsize=2)
q_feat  = queue.Queue(maxsize=4)

def put_drop(q:queue.Queue, item):
    try: q.put(item, timeout=0.003)
    except queue.Full:
        try: q.get_nowait()
        except Exception: pass
        q.put(item)

def get_latest(q:queue.Queue):
    last = None
    try:
        while True: last = q.get_nowait()
    except queue.Empty: pass
    return last

# ---------------- MediaPipe wrappers ----------------
class MPFaceDetector:
    def __init__(self):
        self.ok = MP_OK
        if self.ok:
            self.det = mp.solutions.face_detection.FaceDetection(
                model_selection=0, min_detection_confidence=0.5)
        else:
            self.det = None
            print("[MP] FaceDetection no disponible — ROI off")

    def __call__(self, bgr: np.ndarray):
        if not self.ok: return None
        rgb = cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB)
        r = self.det.process(rgb)
        if not r.detections: return None
        d = r.detections[0]
        bb = d.location_data.relative_bounding_box
        h, w = bgr.shape[:2]
        x, y, ww, hh = int(bb.xmin*w), int(bb.ymin*h), int(bb.width*w), int(bb.height*h)
        # margen
        mx, my = int(ROI_MARGIN*ww), int(ROI_MARGIN*hh)
        x1, y1 = max(0, x-mx), max(0, y-my)
        x2, y2 = min(w-1, x+ww+mx), min(h-1, y+hh+my)
        return (x1, y1, x2, y2), float(d.score[0])

class MPFaceMesh:
    def __init__(self):
        self.ok = MP_OK
        if self.ok:
            self.mesh = mp.solutions.face_mesh.FaceMesh(
                static_image_mode=False, max_num_faces=1, refine_landmarks=True,
                min_detection_confidence=0.5, min_tracking_confidence=0.5)
        else:
            self.mesh=None; print("[MP] FaceMesh no disponible")
    def __call__(self, bgr: np.ndarray) -> Optional[np.ndarray]:
        if not self.ok: return None
        rgb = cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB)
        r = self.mesh.process(rgb)
        if not r.multi_face_landmarks: return None
        lm = r.multi_face_landmarks[0].landmark
        h, w = bgr.shape[:2]
        pts = np.array([(p.x*w, p.y*h) for p in lm], dtype=np.float32)
        return pts

# ---------------- EAR / MAR ----------------
LE = [33,160,158,133,153,144]
RE = [263,387,385,362,380,373]
MOUTH_H = (13,14); MOUTH_W = (78,308)

def _ear6(p):
    d = lambda a,b: np.linalg.norm(p[a]-p[b])
    num = d(1,5) + d(2,4); den = 2.0*d(0,3)
    return (num/den) if den>1e-6 else 0.0
def compute_EAR(pts): return 0.5*(_ear6(pts[LE])+_ear6(pts[RE]))
def compute_MAR(pts):
    a,b = MOUTH_H; c,d = MOUTH_W
    h = np.linalg.norm(pts[a]-pts[b]); w = np.linalg.norm(pts[c]-pts[d])
    return (h/w) if w>1e-6 else 0.0

# ---------------- Filters / Windows ----------------
class EMA:
    def __init__(self, a=0.25): self.a=a; self.y=None
    def __call__(self,x): self.y = x if self.y is None else self.a*x+(1-self.a)*self.y; return self.y

class PERCLOSWindow:
    def __init__(self, seconds, hz): self.buf=deque(maxlen=int(seconds*hz))
    def update(self, eye_closed:bool)->float:
        self.buf.append(1 if eye_closed else 0)
        return sum(self.buf)/len(self.buf) if self.buf else 0.0

class EventRateWin:
    """Cuenta eventos; expone (rate_per_min, coverage_s).
       - rate_per_min = eventos en últimos 60 s (no extrapola).
       - coverage_s   = cuántos segundos reales lleva la ventana poblándose.
    """
    def __init__(self, win_s=60.0):
        self.win=win_s; self.ts=deque(); self.first=None
    def push(self,t):
        self.ts.append(t); self.first = self.first or t
        self._trim(t)
    def _trim(self,tn):
        while self.ts and (tn-self.ts[0]>self.win): self.ts.popleft()
        if self.first and (tn - self.first > self.win):  # ya tenemos ventana llena
            self.first = tn - self.win
    def rate_and_coverage(self, tn):
        self._trim(tn)
        # rate = cantidad de eventos en últimos win_s (no extrapolada)
        rate = len(self.ts)
        # coverage: tiempo observado desde que empezó hasta ahora, acotado en win_s
        if self.first is None:
            cov = 0.0
        else:
            cov = max(0.0, min(self.win, tn - self.first))
        return rate, cov

class BlinkDetector:
    def __init__(self, th=EAR_BLINK_TH, min_open_frames=2):
        self.th=th; self.min_open=min_open_frames; self.closed=False; self.open_frames=0; self.rate=EventRateWin(EVENT_RATE_WINDOW_S)
    def update(self, ear_s, t):
        if ear_s<self.th: self.closed=True; self.open_frames=0
        else:
            if self.closed and self.open_frames>=self.min_open: self.rate.push(t)
            self.closed=False; self.open_frames+=1
    def rate_cov(self, t): return self.rate.rate_and_coverage(t)

class YawnDetector:
    def __init__(self, th=MAR_YAWN_TH, min_len_frames=5):
        self.th=th; self.min_len=min_len_frames; self.opening=0; self.rate=EventRateWin(EVENT_RATE_WINDOW_S)
    def update(self, mar_s, t):
        if mar_s>self.th: self.opening+=1
        else:
            if self.opening>=self.min_len: self.rate.push(t)
            self.opening=0
    def rate_cov(self, t): return self.rate.rate_and_coverage(t)

# ---------------- Clasificador (tabla exacta + confianza) ----------------
def closeness_to_range(x,a,b):
    if a<=x<=b: return 1.0
    d=min(abs(x-a),abs(x-b)); return max(0.0, 1.0 - d/max(1.0,(b-a)))

def classify_by_table(perclos, blinks, yawns, blink_confident, yawn_confident)->str:
    """Aplica tu tabla, pero:
       - NO usa 'blinks < 6 => MICROSUEÑO' si blink_confident=False.
       - En SOMNOLENCIA/FATIGA, ignora el criterio de blinks si blink_confident=False.
       - En YAWNS, puede ignorar criterio si yawn_confident=False (opcional).
    """
    # MICROSUEÑO por PERCLOS alto siempre válido
    if perclos > 0.8:
        return "MICROSUEÑO"

    # MICROSUEÑO por blinks muy bajos SOLO si hay confianza de cobertura
    if blink_confident and blinks < 6:
        return "MICROSUEÑO"

    # SOMNOLENCIA: requiere yawns>4 (si hay confianza) + perclos rango
    somno_blinks_ok = (6 <= blinks <= 12) if blink_confident else True  # si no hay confianza, no bloquea
    somno_yawns_ok = (yawns > 4) if yawn_confident else True            # opcionalmente flexible
    if 0.4 <= perclos <= 0.8 and somno_blinks_ok and somno_yawns_ok:
        return "SOMNOLENCIA"

    # FATIGA
    fatiga_blinks_ok = (12 <= blinks <= 16) if blink_confident else True
    fatiga_yawns_ok  = (1 <= yawns <= 4) if yawn_confident else True
    if 0.3 <= perclos < 0.4 and fatiga_blinks_ok and fatiga_yawns_ok:
        return "FATIGA"

    # NORMAL (aquí sí conviene exigir blinks si ya hay confianza; si no, permitimos NORMAL por perclos+yawns)
    normal_blinks_ok = (17 <= blinks <= 25) if blink_confident else True
    normal_yawns_ok  = (0 <= yawns <= 1) if yawn_confident else True
    if perclos < 0.3 and normal_blinks_ok and normal_yawns_ok:
        return "NORMAL"

    # Fallback por cercanía
    scores={
        "NORMAL"      : (0.3-perclos if perclos<0.3 else 0)+ (closeness_to_range(blinks,17,25) if blink_confident else 0.5) + (closeness_to_range(yawns,0,1) if yawn_confident else 0.5),
        "FATIGA"      : closeness_to_range(perclos,0.3,0.4) + (closeness_to_range(blinks,12,16) if blink_confident else 0.5) + (closeness_to_range(yawns,1,4) if yawn_confident else 0.5),
        "SOMNOLENCIA" : closeness_to_range(perclos,0.4,0.8) + (closeness_to_range(blinks,6,12) if blink_confident else 0.5) + ((1.0 if yawn_confident and yawns>4 else 0.5))
    }
    if perclos>0.75:
        return "SOMNOLENCIA"
    return max(scores,key=scores.get)

# ---------------- MQTT ----------------
def init_mqtt(host, port, client_id):
    if mqtt is None:
        print("[MQTT] paho no disponible — consola"); return None
    c = mqtt.Client(client_id=client_id)
    try: c.connect(host,port,60); c.loop_start(); print("[MQTT] conectado"); return c
    except Exception as e: print("[MQTT] fallo:",e); return None

def mqtt_publish(client, topic, payload)->bool:
    if client is None:
        print(f"[MQTT-FAKE] {topic}: {json.dumps(payload)}"); return True
    try:
        r = client.publish(topic, json.dumps(payload), qos=1); r.wait_for_publish(timeout=1.0)
        return r.is_published()
    except Exception: return False

# ---------------- Alert Manager (escalamiento + histéresis) ----------------
class AlertManager:
    def __init__(self, mqtt_client, topic="fatiga/alerta"):
        self.level=0; self.last_state="NORMAL"; self.state_since=now(); self.recover_since=None
        self.mqtt=mqtt_client; self.topic=topic
    def update(self, estado:str):
        t=now()
        if estado!=self.last_state:
            self.last_state=estado; self.state_since=t; self.recover_since=None
        dur = t-self.state_since
        target=0
        if estado=="SOMNOLENCIA":
            if dur>=SOMNO_LVL3_S: target=3
            elif dur>=SOMNO_LVL2_S: target=2
            elif dur>=SOMNO_LVL1_S: target=1
        elif estado=="MICROSUEÑO": target=3
        elif estado=="FATIGA":
            if dur>=FATIGA_LVL2_S: target=2
            elif dur>=FATIGA_LVL1_S: target=1

        if estado=="NORMAL":
            self.recover_since = self.recover_since or t
            if (t-self.recover_since)>=RECOVERY_DOWN_S: target=max(0, self.level-1)
            else: target=max(target, self.level)

        if target!=self.level:
            self.level=target
            mqtt_publish(self.mqtt, self.topic, {"ts":int(t),"level":int(target)})

# ---------------- Telemetry store-and-forward ----------------
class TelemetryBuffer:
    def __init__(self, path="/tmp/telemetry.jsonl", device_id="EDGE"):
        self.path=path; self.seq=0; self.device_id=device_id
    def enqueue(self, payload:dict):
        payload.setdefault("device_id", self.device_id)
        payload.setdefault("v",1)
        payload["seq"]=self.seq; self.seq+=1
        with open(self.path,"a") as f: f.write(json.dumps(payload)+"\n")
    def flush(self, client, topic:str):
        try: lines=open(self.path,"r").readlines()
        except FileNotFoundError: return
        sent=0
        for ln in lines:
            p=json.loads(ln)
            if mqtt_publish(client, topic, p): sent+=1
            else: break
        if sent:
            with open(self.path,"w") as f:
                for ln in lines[sent:]: f.write(ln)

# ---------------- Health / Profiler ----------------
class HealthProfiler(threading.Thread):
    def __init__(self, mqtt_client, device_id, face_seen_flag, get_fps_cam, get_fps_mesh,
                 topic="telemetry/health"):
        super().__init__(daemon=True)
        self.mqtt=mqtt_client; self.topic=topic; self.did=device_id
        self.face_seen_flag=face_seen_flag; self.get_fps_cam=get_fps_cam; self.get_fps_mesh=get_fps_mesh
        self.last_beat={"T0":now(),"T1":now(),"T2":now(),"T3":now(),"T4":now()}
        self.no_face_since=None
    def beat(self,name): self.last_beat[name]=now()
    def read_temp(self)->float:
        try:
            p="/sys/class/thermal/thermal_zone0/temp"
            return int(open(p).read().strip())/1000.0
        except Exception: return -1.0
    def run(self):
        while not stop.is_set():
            time.sleep(2.0); t=now()
            stalled=[k for k,v in self.last_beat.items() if (t-v)>5.0]
            if self.face_seen_flag.is_set():
                self.no_face_since=None; self.face_seen_flag.clear()
            else:
                self.no_face_since = self.no_face_since or t
            no_face = 0 if self.no_face_since is None else int(t-self.no_face_since)
            payload={"v":1,"device_id":self.did,"ts":int(t),
                     "fps_cam":round(self.get_fps_cam(),1),
                     "fps_mesh":round(self.get_fps_mesh(),1),
                     "temp_c":round(self.read_temp(),1),
                     "stalled":stalled,"no_face_s":no_face}
            mqtt_publish(self.mqtt, self.topic, payload)

# ---------------- Threads ----------------
class T0Capture(threading.Thread):
    def __init__(self, health:HealthProfiler):
        super().__init__(daemon=True); self.health=health
        self.cam=None; self.last=now(); self.fps=0.0
    def get_fps(self): return self.fps
    def run(self):
        self.cam=cv2.VideoCapture(0)
        self.cam.set(cv2.CAP_PROP_FRAME_WIDTH, CAM_SIZE[0])
        self.cam.set(cv2.CAP_PROP_FRAME_HEIGHT,CAM_SIZE[1])
        self.cam.set(cv2.CAP_PROP_FPS, TARGET_FPS)
        if not self.cam.isOpened(): raise RuntimeError("No se pudo abrir cámara")
        while not stop.is_set():
            ok,bgr=self.cam.read()
            if not ok: continue
            t=now(); self.fps = 1.0/max(1e-3, t-self.last); self.last=t
            put_drop(q_frame, Frame(ts=t,bgr=bgr,fps=self.fps))
            self.health.beat("T0")

class T1Detect(threading.Thread):
    def __init__(self, health:HealthProfiler):
        super().__init__(daemon=True); self.health=health
        self.det=MPFaceDetector(); self.period=1.0/DETECT_HZ; self.last=0; self.roi=(0,0,0,0)
    def run(self):
        while not stop.is_set():
            fr = get_latest(q_frame) or q_frame.get()
            if (now()-self.last) < self.period:
                put_drop(q_roi, FaceROI(ts=fr.ts, xyxy=self.roi, conf=0.0)); time.sleep(0.002); continue
            self.last=now()
            out = self.det(fr.bgr)
            if out is not None: self.roi, conf = out
            put_drop(q_roi, FaceROI(ts=fr.ts, xyxy=self.roi, conf=1.0))
            self.health.beat("T1")

class T2FaceMesh(threading.Thread):
    def __init__(self, health:HealthProfiler):
        super().__init__(daemon=True); self.fm=MPFaceMesh()
        self.period=1.0/FACEMESH_HZ; self.last=0; self.fps=0.0
        self.face_seen_flag = health.face_seen_flag; self.health=health
    def get_fps(self): return self.fps
    def run(self):
        while not stop.is_set():
            fr = get_latest(q_frame) or q_frame.get()
            roi = get_latest(q_roi) or FaceROI(ts=fr.ts, xyxy=(0,0,0,0), conf=0.0)
            if (now()-self.last) < self.period: time.sleep(0.001); continue
            self.last=now(); t0=now()
            x1,y1,x2,y2 = roi.xyxy
            crop = fr.bgr[y1:y2, x1:x2] if (x2>x1 and y2>y1) else fr.bgr
            pts = self.fm(crop)
            if pts is not None:
                if crop is not fr.bgr:
                    pts[:,0]+=x1; pts[:,1]+=y1
                put_drop(q_lm, Landmarks(ts=fr.ts, pts=pts))
                self.face_seen_flag.set()
            self.fps = 1.0/max(1e-3, now()-t0)
            self.health.beat("T2")

class T3Features(threading.Thread):
    def __init__(self, health:HealthProfiler):
        super().__init__(daemon=True); self.health=health
        self.ema_e, self.ema_m = EMA(0.25), EMA(0.25)
        self.perclos = PERCLOSWindow(PERCLOS_WINDOW_SEC, FACEMESH_HZ)
        self.blinks  = BlinkDetector(EAR_BLINK_TH,2)
        self.yawns   = YawnDetector(MAR_YAWN_TH,5)
    def run(self):
        while not stop.is_set():
            lm = q_lm.get()
            ear = compute_EAR(lm.pts); mar=compute_MAR(lm.pts)
            ear_s, mar_s = self.ema_e(ear), self.ema_m(mar)
            p = self.perclos.update(eye_closed=(ear_s<EAR_BLINK_TH))
            self.blinks.update(ear_s, lm.ts); self.yawns.update(mar_s, lm.ts)
            bl_rate, bl_cov = self.blinks.rate_cov(lm.ts)
            yw_rate, yw_cov = self.yawns.rate_cov(lm.ts)
            feat = Features(ts=lm.ts, ear=ear_s, mar=mar_s, perclos=p,
                            blinks=bl_rate, yawns=yw_rate,
                            blink_cov_s=bl_cov, yawn_cov_s=yw_cov)
            put_drop(q_feat, feat)
            self.health.beat("T3")

# ---------------- Decisión + Alerts + Telemetry ----------------
class T4Decision(threading.Thread):
    def __init__(self, client, device_id, alert_mgr:AlertManager,
                 telemetry:TelemetryBuffer, state_topic="fatiga/estado"):
        super().__init__(daemon=True)
        self.client=client; self.did=device_id; self.alert=alert_mgr
        self.telemetry=telemetry; self.topic=state_topic
        self.estado_last=None
    def run(self):
        while not stop.is_set():
            f = q_feat.get()

            # Confianza por cobertura temporal:
            blink_conf = (f.blink_cov_s >= MIN_COVERAGE_BLINKS_S)
            yawn_conf  = (f.yawn_cov_s  >= MIN_COVERAGE_YAWNS_S)

            estado = classify_by_table(f.perclos, f.blinks, f.yawns, blink_conf, yawn_conf)

            if VERBOSE:
                vprint(f"[DEC] ts={int(f.ts)} P={f.perclos:.3f} BL={f.blinks}({f.blink_cov_s:.0f}s) "
                       f"YW={f.yawns}({f.yawn_cov_s:.0f}s) -> {estado} "
                       f"[blink_conf={blink_conf} yawn_conf={yawn_conf}]")

            payload={"device_id":self.did,"estado":estado,
                     "perclos":round(f.perclos,3),
                     "blinks":int(f.blinks),"yawns":int(f.yawns),
                     "ts":int(f.ts)}

            # store-and-forward (enfiletar SIEMPRE) + flush oportunista
            self.telemetry.enqueue(payload)
            self.telemetry.flush(self.client, self.topic)

            # alerts
            self.alert.update(estado)
            self.estado_last=estado

# ---------------- Main ----------------
def main():
    global VERBOSE
    ap=argparse.ArgumentParser()
    ap.add_argument("--client_id", default="EDGE_RPI")
    ap.add_argument("--mqtt_host", default="localhost")
    ap.add_argument("--mqtt_port", type=int, default=1883)
    ap.add_argument("--verbose", action="store_true", help="Logs detallados")
    args=ap.parse_args()
    VERBOSE = args.verbose

    client = init_mqtt(args.mqtt_host, args.mqtt_port, args.client_id)

    face_seen_flag = threading.Event()
    # dummy getters; se rellenan con instancias reales
    get_cam_fps = lambda: 0.0
    get_mesh_fps= lambda: 0.0

    # Health
    health = HealthProfiler(client, args.client_id, face_seen_flag, lambda: get_cam_fps(), lambda: get_mesh_fps())
    # Telemetry buffer y Alerts
    telemetry = TelemetryBuffer("/tmp/telemetry.jsonl", args.client_id)
    alert_mgr = AlertManager(client, "fatiga/alerta")

    # Threads
    t0 = T0Capture(health)
    t1 = T1Detect(health)
    t2 = T2FaceMesh(health)
    t3 = T3Features(health)
    t4 = T4Decision(client, args.client_id, alert_mgr, telemetry, "fatiga/estado")

    # vincular getters reales
    def _gc(): return t0.get_fps()
    def _gm(): return t2.get_fps()
    health.get_fps_cam=_gc; health.get_fps_mesh=_gm

    for t in (health,t0,t1,t2,t3,t4): t.start()
    print("[MAIN] Corriendo. Ctrl+C para salir. (Usa --verbose para logs)")
    try:
        while not stop.is_set(): time.sleep(0.05)
    except KeyboardInterrupt:
        pass
    finally:
        stop.set()
        for t in (t4,t3,t2,t1,t0,health):
            t.join(timeout=1.0)
        print("[MAIN] Bye.")

if __name__=="__main__":
    main()
