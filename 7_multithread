# ================== IMPORTS B√ÅSICOS ==================
import os, time, math, json, ssl, csv, queue, threading
from datetime import datetime
from collections import deque

import cv2
import numpy as np
from picamera2 import Picamera2

import mediapipe as mp
from mediapipe.tasks import python as mp_python
from mediapipe.tasks.python import vision
from paho.mqtt import client as mqtt

# ================== CONFIGURACI√ìN ==================
CAM_SIZE = (640, 480)
FRAMES_INTERVAL      = 30
PERCLOS_WINDOW_S     = 60.0
MIN_CLOSE_MS         = 200
MICROSLEEP_FRAMES    = 15

EYE_CLOSED_THRESHOLD = 0.009
YAWN_MAR_THRESHOLD   = 0.65
YAWN_HOLD_FRAMES     = 5

CSV_FILENAME         = "session_log.csv"
FRAME_CSV_FILENAME   = "session_log_frames.csv"
WRITE_FRAME_CSV      = True
HEADLESS             = os.getenv("HEADLESS", "0") == "1"

# AWS IoT Core
ENDPOINT   = "a1omfl67425kjv-ats.iot.us-east-2.amazonaws.com"
PORT       = 8883
CLIENT_ID  = "rsp5"
TOPIC      = "alertas"
CA_PATH    = "aws/AmazonRootCA1.pem"
CERT_PATH  = "aws/certificate.pem.crt"
KEY_PATH   = "aws/private.pem.key"

MODEL_PATH = "facemesh/face_landmarker.task"

# Bandas de EAR (clasificaci√≥n directa)
EAR_BANDS = {
    "NORMAL":      (0.25,  1.00),
    "FATIGA":      (0.21,  0.25),
    "SOMNOLENCIA": (0.15,  0.21),
    "MICROSUE√ëO":  (0.00,  0.15),
}

# Tabla de umbrales blink/yawn
BLINK_MICRO_MAX   = 6.0
BLINK_SOMNO_MAX   = 12.0
BLINK_FATIGA_MAX  = 20.0
BLINK_NORM_MIN    = 17.0
BLINK_NORM_MAX    = 25.0
YAWN_FATIGA_MIN   = 1.0
YAWN_FATIGA_MAX   = 4.0
YAWN_SOMNO_MIN    = 4.0  # >4 ‚Üí somnolencia

# ================== COLAS & CONTROL ==================
frame_queue    = queue.Queue(maxsize=2)
marks_queue    = queue.Queue(maxsize=4)
metrics_queue  = queue.Queue(maxsize=8)   # bus com√∫n (ventanas, frames, decisiones)
decision_queue = queue.Queue(maxsize=4)
annot_queue    = queue.Queue(maxsize=2)
stop_event     = threading.Event()

def q_put_drop_oldest(q: queue.Queue, item):
    if q.full():
        try: q.get_nowait()
        except queue.Empty: pass
    q.put(item)

# ================== HELPERS ==================
def euclidean(a, b):
    return math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2)

def eye_aspect_ratio_like(landmarks, right=True):
    top, bottom = (landmarks[145], landmarks[159]) if right else (landmarks[374], landmarks[386])
    return euclidean(top, bottom)

def mouth_aspect_ratio(landmarks):
    vertical_pairs = [(13, 14), (82, 87), (312, 317)]
    horizontals = (78, 308)
    v = np.mean([euclidean(landmarks[a], landmarks[b]) for a, b in vertical_pairs])
    h = euclidean(landmarks[horizontals[0]], landmarks[horizontals[1]])
    return (v / h) if h > 0 else 0.0

def put_text_rgb(rgb_frame, text, pos=(12, 28), color=(0, 255, 255)):
    cv2.putText(rgb_frame, text, pos, cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2, cv2.LINE_AA)

def draw_landmarks_on_frame_rgb(rgb_frame, marks):
    h, w = rgb_frame.shape[:2]
    for lm in marks[0]:
        x = int(lm.x * w); y = int(lm.y * h)
        cv2.circle(rgb_frame, (x, y), 1, (0, 255, 0), -1)

def initialize_detector():
    if not os.path.exists(MODEL_PATH):
        raise FileNotFoundError(f"Modelo no encontrado: {MODEL_PATH}")
    base_options = mp_python.BaseOptions(model_asset_path=MODEL_PATH)
    options = vision.FaceLandmarkerOptions(
        base_options=base_options,
        output_face_blendshapes=False,
        output_facial_transformation_matrixes=False,
        num_faces=1
    )
    return vision.FaceLandmarker.create_from_options(options)

def estado_por_ear(ear_val):
    if ear_val is None:
        return None
    for estado, (mn, mx) in EAR_BANDS.items():
        if mn <= ear_val < mx:
            return estado
    return "NORMAL"

# ================== CAPTURE WORKER ==================
class CaptureWorker(threading.Thread):
    def __init__(self, stop_evt):
        super().__init__(daemon=True)
        self.stop_evt = stop_evt
        self.picam2 = None

    def run(self):
        try:
            self.picam2 = Picamera2()
            cfg = self.picam2.create_preview_configuration(main={"format":"RGB888","size":CAM_SIZE})
            self.picam2.configure(cfg)
            self.picam2.start()
            time.sleep(0.2)
            print("üü¢ C√°mara lista (Picamera2).")
            while not self.stop_evt.is_set():
                try:
                    rgb = self.picam2.capture_array()
                    q_put_drop_oldest(frame_queue, (time.time(), rgb))
                except Exception:
                    time.sleep(0.005)
        except Exception as e:
            import traceback; print(f"‚ùå CaptureWorker: {e}"); traceback.print_exc()
            self.stop_evt.set()
        finally:
            try: self.picam2.stop()
            except Exception: pass

# ================== LANDMARK WORKER ==================
class LandmarkWorker(threading.Thread):
    def __init__(self, stop_evt):
        super().__init__(daemon=True)
        self.stop_evt = stop_evt
        self.detector = initialize_detector()

    def run(self):
        try:
            while not self.stop_evt.is_set():
                try:
                    ts, rgb = frame_queue.get(timeout=0.2)
                except queue.Empty:
                    continue

                mp_image = mp.Image(image_format=mp.ImageFormat.SRGB, data=rgb)
                result = self.detector.detect(mp_image)

                valid = bool(result.face_landmarks)
                lms = result.face_landmarks if valid else None

                if valid:
                    draw_landmarks_on_frame_rgb(rgb, lms)

                q_put_drop_oldest(marks_queue, (ts, rgb, lms, valid))
                frame_queue.task_done()
        except Exception as e:
            import traceback; print(f"‚ùå LandmarkWorker: {e}"); traceback.print_exc()
            self.stop_evt.set()

# ================== METRICS WORKER (PERCLOS/blink/yawn + EAR bands) ==================
class MetricsWorker(threading.Thread):
    def __init__(self, stop_evt):
        super().__init__(daemon=True)
        self.stop_evt = stop_evt
        # ventana corta
        self.frames_cnt = 0
        self.closed_frames = 0
        self.closed_streak = 0
        self.microsleep_flag = False

        self.blink_count_win = 0
        self.yawn_count_win  = 0
        self.eyes_closed_prev = False
        self.yawn_frames = 0
        self.window_start_ts = time.time()

        # PERCLOS deslizante
        self.perclos_win = deque()
        self.perclos_win_times = deque()
        self.min_close_fr = None
        self.run_closed = 0
        self.fps_est = 30.0
        self._fps_init_time = time.time()
        self._fps_init_frames = 0

        # contadores por frame (para CSV por frame si lo requiere Telemetry)
        self.closed_run_ms = 0.0
        self.last_ts = None

    def _update_fps_minclose(self):
        if self.min_close_fr is None:
            self._fps_init_frames += 1
            dt = max(time.time() - self._fps_init_time, 1e-3)
            self.fps_est = max(5.0, min(60.0, self._fps_init_frames / dt))
            self.min_close_fr = max(1, int(round((MIN_CLOSE_MS/1000.0) * self.fps_est)))

    def _update_perclos_sliding(self, valid, eyes_closed_raw, t_s):
        while self.perclos_win_times and (t_s - self.perclos_win_times[0] > PERCLOS_WINDOW_S):
            self.perclos_win_times.popleft()
            self.perclos_win.popleft()
        if not valid:
            return
        if eyes_closed_raw:
            self.run_closed += 1
            self.perclos_win.append(0); self.perclos_win_times.append(t_s)
            if self.run_closed >= self.min_close_fr:
                self.perclos_win[-1] = 1
                if self.run_closed == self.min_close_fr:
                    n_back = min(self.min_close_fr - 1, len(self.perclos_win) - 1)
                    for i in range(1, n_back + 1):
                        self.perclos_win[-1 - i] = 1
        else:
            self.run_closed = 0
            self.perclos_win.append(0); self.perclos_win_times.append(t_s)

    def _perclos_current(self):
        denom = len(self.perclos_win)
        if denom == 0: return 0.0, 0.0
        frac = sum(self.perclos_win) / float(denom)
        return frac, (frac * 100.0)

    def run(self):
        try:
            while not self.stop_evt.is_set():
                try:
                    ts, rgb, lms, valid = marks_queue.get(timeout=0.2)
                except queue.Empty:
                    continue

                self._update_fps_minclose()
                if self.last_ts is None:
                    self.last_ts = ts
                dt_ms = (ts - self.last_ts) * 1000.0 if ts >= self.last_ts else 33.3
                self.last_ts = ts

                eyes_closed_raw = 0
                overlay = "Sin rostro"
                ear_min = None
                mar = None
                blink_evt = 0
                yawn_evt  = 0

                if valid:
                    l = lms[0]
                    ear_r = eye_aspect_ratio_like(l, right=True)
                    ear_l = eye_aspect_ratio_like(l, right=False)
                    ear_min = min(ear_r, ear_l)
                    eyes_closed = (ear_r < EYE_CLOSED_THRESHOLD and ear_l < EYE_CLOSED_THRESHOLD)
                    mar = mouth_aspect_ratio(l)

                    if eyes_closed:
                        self.closed_frames += 1
                        self.closed_streak += 1
                        self.closed_run_ms += dt_ms
                    else:
                        self.closed_streak = 0
                        self.closed_run_ms = 0.0

                    if not self.eyes_closed_prev and eyes_closed:
                        self.eyes_closed_prev = True
                    elif self.eyes_closed_prev and not eyes_closed:
                        self.blink_count_win += 1
                        blink_evt = 1
                        self.eyes_closed_prev = False

                    if mar > YAWN_MAR_THRESHOLD:
                        self.yawn_frames += 1
                    else:
                        if self.yawn_frames > YAWN_HOLD_FRAMES:
                            self.yawn_count_win += 1
                            yawn_evt = 1
                        self.yawn_frames = 0

                    eyes_closed_raw = 1 if eyes_closed else 0

                    # ventana corta cerrada
                    self.frames_cnt += 1
                    if self.closed_streak >= MICROSLEEP_FRAMES:
                        self.microsleep_flag = True

                    if self.frames_cnt >= FRAMES_INTERVAL:
                        elapsed = max(time.time() - self.window_start_ts, 1e-3)
                        perclos_pct_win = 100.0 * self.closed_frames / float(max(1, FRAMES_INTERVAL))
                        blink_rate  = (self.blink_count_win * 60.0) / elapsed
                        yawn_rate   = (self.yawn_count_win  * 60.0) / elapsed
                        # mensaje de ventana (DecisionWorker decide)
                        q_put_drop_oldest(metrics_queue, {
                            "type": "win",
                            "ts": ts,
                            "perclos_pct_win": perclos_pct_win,
                            "blink_rate": blink_rate,
                            "yawn_rate": yawn_rate,
                            "microsleep_flag": self.microsleep_flag,
                            "ear_min": ear_min  # √∫ltimo valor (para logging/diagn√≥stico)
                        })

                        # reset de ventana
                        self.frames_cnt = 0
                        self.closed_frames = 0
                        self.closed_streak = 0
                        self.microsleep_flag = False
                        self.blink_count_win = 0
                        self.yawn_count_win  = 0
                        self.window_start_ts = time.time()

                    # overlay por EAR instant√°neo
                    ear_state = estado_por_ear(ear_min)
                    overlay = ear_state if ear_state else "NORMAL"

                # PERCLOS deslizante continuo (60s)
                self._update_perclos_sliding(valid, eyes_closed_raw, ts)
                perclos_frac, perclos_pct = self._perclos_current()

                # UI
                put_text_rgb(rgb, overlay, (12, 28))
                bgr = cv2.cvtColor(rgb, cv2.COLOR_RGB2BGR)
                q_put_drop_oldest(annot_queue, bgr)

                # Mensaje frame‚ÜíDecision y Telemetry (para CSV frame)
                q_put_drop_oldest(decision_queue, {
                    "type": "frame",
                    "ts": ts,
                    "ear_min": ear_min,
                    "mar": mar,
                    "eye_closed": eyes_closed_raw,
                    "blink_evt": blink_evt,
                    "yawn_evt": yawn_evt,
                    "closed_run_ms": self.closed_run_ms,
                    "perclos_pct": perclos_pct
                })

                marks_queue.task_done()
        except Exception as e:
            import traceback; print(f"‚ùå MetricsWorker: {e}"); traceback.print_exc()
            self.stop_evt.set()

# ================== DECISION WORKER (fusi√≥n con prioridad EAR) ==================
class DecisionWorker(threading.Thread):
    def __init__(self, stop_evt):
        super().__init__(daemon=True)
        self.stop_evt = stop_evt
        self.latest_frame = None  # para CSV por frame
        self.rank = {"NORMAL":0, "FATIGA":1, "SOMNOLENCIA":2, "MICROSUE√ëO":3}

    def _estado_por_perclos(self, perclos):
        if perclos >= 60.0: return "SOMNOLENCIA"
        if perclos >= 40.0: return "FATIGA"
        return "NORMAL"

    def _estado_por_blink_rate(self, rate):
        if rate < BLINK_MICRO_MAX:      return "MICROSUE√ëO"
        if rate < BLINK_SOMNO_MAX:      return "SOMNOLENCIA"
        if rate <= BLINK_FATIGA_MAX:    return "FATIGA"
        if BLINK_NORM_MIN <= rate <= BLINK_NORM_MAX: return "NORMAL"
        return "NORMAL"

    def _estado_por_yawn_rate(self, rate):
        if rate > YAWN_SOMNO_MIN:                       return "SOMNOLENCIA"
        if YAWN_FATIGA_MIN <= rate <= YAWN_FATIGA_MAX:  return "FATIGA"
        return "NORMAL"

    def run(self):
        try:
            while not self.stop_evt.is_set():
                # recojo per-frame para telemetry
                try:
                    msg = decision_queue.get(timeout=0.05)
                    if msg.get("type") == "frame":
                        self.latest_frame = msg
                        # tambi√©n mandamos a metrics_queue para que Telemetry lo escriba
                        q_put_drop_oldest(metrics_queue, msg)
                    decision_queue.task_done()
                except queue.Empty:
                    pass

                # proceso ventanas
                try:
                    win = metrics_queue.get(timeout=0.05)
                except queue.Empty:
                    continue

                if win.get("type") == "win":
                    perclos_pct_win = win["perclos_pct_win"]
                    blink_rate      = win["blink_rate"]
                    yawn_rate       = win["yawn_rate"]
                    microsleep_flag = win["microsleep_flag"]
                    ts              = win["ts"]

                    # si tengo el √∫ltimo frame, uso su perclos y su EAR
                    perclos_pct_sliding = 0.0
                    estado_ear = None
                    if self.latest_frame is not None:
                        perclos_pct_sliding = self.latest_frame.get("perclos_pct", 0.0)
                        estado_ear = estado_por_ear(self.latest_frame.get("ear_min", None))

                    # candidato por tasas
                    cand_tasas = [
                        self._estado_por_blink_rate(blink_rate),
                        self._estado_por_yawn_rate(yawn_rate),
                        self._estado_por_perclos(max(perclos_pct_win, perclos_pct_sliding))
                    ]
                    estado_tasas = max(cand_tasas, key=lambda x: self.rank[x])

                    if microsleep_flag:
                        estado_final = "MICROSUE√ëO"
                    else:
                        if estado_ear is None:
                            estado_final = estado_tasas
                        else:
                            # prioriza el m√°s grave entre EAR y tasas
                            estado_final = estado_ear if self.rank[estado_ear] > self.rank[estado_tasas] else estado_tasas

                    q_put_drop_oldest(metrics_queue, {
                        "type": "decision",
                        "ts": ts,
                        "estado": estado_final,
                        "perclos_pct_sliding": perclos_pct_sliding,
                        "perclos_pct_win": perclos_pct_win,
                        "blink_rate": blink_rate,
                        "yawn_rate": yawn_rate
                    })
                else:
                    # reinyecta mensajes que no son de ventana
                    q_put_drop_oldest(metrics_queue, win)
        except Exception as e:
            import traceback; print(f"‚ùå DecisionWorker: {e}"); traceback.print_exc()
            self.stop_evt.set()

# ================== TELEMETRY WORKER (CSV/MQTT) ==================
class TelemetryWorker(threading.Thread):
    def __init__(self, stop_evt):
        super().__init__(daemon=True)
        self.stop_evt = stop_evt
        self.csv_file = open(CSV_FILENAME, mode='w', newline='')
        self.csv_writer = csv.writer(self.csv_file)
        self.csv_writer.writerow(['Timestamp','Estado','PERCLOS_sliding(%)','PERCLOS_win(%)',
                                  'BlinkRate(/min)','YawnRate(/min)'])
        self.frame_csv = open(FRAME_CSV_FILENAME, mode='w', newline='') if WRITE_FRAME_CSV else None
        if self.frame_csv:
            self.frame_writer = csv.writer(self.frame_csv)
            self.frame_writer.writerow([
                'ts_s','EAR_min','MAR','EyeClosed','BlinkEvt','YawnEvt',
                'ClosedRun_ms','PERCLOS_sliding(%)','Estado_EAR'
            ])

        self.client = mqtt.Client(client_id=CLIENT_ID)
        def _on_connect(client, userdata, flags, rc):
            print("‚úÖ Conectado a AWS IoT Core" if rc == 0 else f"‚ùå Error MQTT rc={rc}")
        self.client.on_connect = _on_connect

        try:
            self.client.tls_set(ca_certs=CA_PATH, certfile=CERT_PATH, keyfile=KEY_PATH, tls_version=ssl.PROTOCOL_TLSv1_2)
            self.client.connect(ENDPOINT, PORT, keepalive=60)
            self.client.loop_start()
            print("üîó MQTT (AWS IoT) inicializado.")
        except Exception as e:
            import traceback; print(f"‚ö†Ô∏è MQTT init: {e}"); traceback.print_exc()
            self.client = None

    def _publish(self, payload, qos=1):
        if not self.client: return
        try:
            self.client.publish(TOPIC, json.dumps(payload), qos=qos)
        except Exception:
            try: self.client.reconnect()
            except Exception: pass

    def run(self):
        try:
            while not self.stop_evt.is_set():
                try:
                    msg = metrics_queue.get(timeout=0.2)
                except queue.Empty:
                    continue

                mtype = msg.get("type")

                # CSV por frame
                if WRITE_FRAME_CSV and mtype == "frame":
                    ts  = msg["ts"]
                    ear = msg.get("ear_min", None)
                    mar = msg.get("mar", None)
                    ear_state = estado_por_ear(ear)
                    self.frame_writer.writerow([
                        f"{ts:.3f}",
                        f"{ear:.4f}" if ear is not None else "",
                        f"{mar:.4f}" if mar is not None else "",
                        int(msg.get("eye_closed", 0)),
                        int(msg.get("blink_evt", 0)),
                        int(msg.get("yawn_evt", 0)),
                        f"{msg.get('closed_run_ms', 0.0):.2f}",
                        f"{msg.get('perclos_pct', 0.0):.2f}",
                        ear_state if ear_state else "NORMAL"
                    ])

                # CSV por ventana + MQTT
                elif mtype == "decision":
                    ts      = msg["ts"]
                    estado  = msg["estado"]
                    per_s   = round(msg["perclos_pct_sliding"], 2)
                    per_w   = round(msg["perclos_pct_win"], 2)
                    br      = round(msg["blink_rate"], 2)
                    yr      = round(msg["yawn_rate"], 2)

                    self.csv_writer.writerow([datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                                              estado, per_s, per_w, br, yr])

                    if estado != "NORMAL":
                        self._publish({
                            "device_id": CLIENT_ID, "estado": estado,
                            "perclos_sliding": per_s, "perclos_win": per_w,
                            "blink_rate": br, "yawn_rate": yr, "ts": int(ts)
                        }, qos=1)

                metrics_queue.task_done()
        except Exception as e:
            import traceback; print(f"‚ùå TelemetryWorker: {e}"); traceback.print_exc()
            self.stop_evt.set()
        finally:
            try: self.csv_file.flush(); self.csv_file.close()
            except Exception: pass
            try:
                if self.frame_csv: self.frame_csv.flush(); self.frame_csv.close()
            except Exception: pass
            try:
                if self.client: self.client.loop_stop(); self.client.disconnect()
            except Exception: pass

# ================== UI WORKER ==================
class UIWorker(threading.Thread):
    def __init__(self, stop_evt):
        super().__init__(daemon=True)
        self.stop_evt = stop_evt

    def run(self):
        if HEADLESS:
            return
        try:
            while not self.stop_evt.is_set():
                try:
                    frame = annot_queue.get(timeout=0.3)
                except queue.Empty:
                    continue
                cv2.imshow("Fatigue Monitor (Multithread + EAR bands)", frame)
                if (cv2.waitKey(1) & 0xFF) == ord('q'):
                    self.stop_evt.set()
                annot_queue.task_done()
        except Exception as e:
            import traceback; print(f"‚ùå UIWorker: {e}"); traceback.print_exc()
            self.stop_evt.set()
        finally:
            if not HEADLESS:
                cv2.destroyAllWindows()

# ================== HEALTH/PROFILER WORKER ==================
class HealthWorker(threading.Thread):
    def __init__(self, stop_evt):
        super().__init__(daemon=True)
        self.stop_evt = stop_evt

    def run(self):
        last = time.time(); c = 0
        try:
            while not self.stop_evt.is_set():
                try:
                    _ = annot_queue.get(timeout=0.2); c += 1
                except queue.Empty:
                    pass
                now = time.time()
                if now - last >= 1.0:
                    print(f"FPS={c/(now-last):.2f}")
                    c = 0; last = now
        except Exception as e:
            import traceback; print(f"‚ùå HealthWorker: {e}"); traceback.print_exc()
            self.stop_evt.set()

# ================== MAIN ==================
def main():
    print("Iniciando hilos (pipeline extendido con EAR bands)‚Ä¶")
    threads = [
        CaptureWorker(stop_event),
        LandmarkWorker(stop_event),
        MetricsWorker(stop_event),
        DecisionWorker(stop_event),
        TelemetryWorker(stop_event),
        UIWorker(stop_event),
        HealthWorker(stop_event),
    ]
    for t in threads: t.start()

    try:
        while not stop_event.is_set():
            time.sleep(0.2)
    finally:
        stop_event.set()
        for t in threads: t.join(timeout=2.0)
        print("Finalizado.")

if __name__ == "__main__":
    main()
